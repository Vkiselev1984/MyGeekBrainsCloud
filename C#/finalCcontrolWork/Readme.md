# Итоговая контрольная работа по основному блоку

## Введение

**С помощью нижепреведенной задачи необходимо продемонстрировать навыки:**
разметки документа с помощью языка MarkDown
использования простых алгоритмов и функций для их построения
работы с массивами и строками
сортировки
рекурсии

## Задача

Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

Я немного модифицировал задачу таким образом, что опеределенный метод должен принимать значания введенных пользователем данных и сохранять их в массив, учитывая условия задачи по количеству символов. 

## Первый блок

Для этого используется метод UserInput, в котором с помощью рекурсии выполняются эти условия.

Инициализация массива и метода в функции Main:
 string[] array = new string[4];
 UserInput(array, 0);

Если введенная пользователем строка удволетворяет условиям, то она сохраняется в массив строк array. Обратите внимание, что при инициализации массива строк с помощью индекса я явно указываю максимальное количество элементов, которые будет обрабатывать метод UserInput, принимая на вход индекс массива. В нашем случае он равен четырем.

Далее UserInput проверяет, что полученный в качестве аргумента индекс больше длины массива, иначе метод прекращает работу: 

if (index >= array.Length)

Как это происходит:
Программа вызывает метод UserInput и c помощью условного оператора if проверяет условие index >= array.Length, получая булевое значение true или false.

До тех пор, пока условие = false, программа будет выводить в консоль сообщение:
Введите данные для индекса {текущий индекс элемента массива}. 
Как только значение станет true метод прекратит работу.

Что происходит после проверки главного условия?

Данные пользователя проходят проверку на условие длинны if (input.Length <= 3), после чего значение присваивается строке input.

Если условие истинно, в рекурсии UserInput(array, index + 1) происходит присваивание переменной input элементу массива с текущим индексом, индекс увеличивается на единицу и метод запускается снова, пока значение главного условия метода UserInput не станет true и не сработает оператор return.

Если условие ложно (длина строки больше 3 символов), выводится предупреждение, и выполняется рекурсия метода  для того же индекса UserInput(array, index), чтобы пользователь мог повторно ввести корректные данные.

## Второй блок

После того, как мы получили данные от пользователя и сохранили их в массиве строк необходимо проеобразовать их в набор двумерного массива или так называемой матрицы.

Для этого я использую метод FillMatrixFromArr, получающий в качестве аргументов значения нашего одномерного массива string[] array, а string[,] matrix это двумерный массив, в которые эти значания будут присваиваться.

static void FillMatrixFromArr(string[] array, string[,] matrix)

Перед этим, в методе Main я проинициализировал строки и колонки. При этом количество строк равно длинне одномерного массива, а количество колонок, в нашем случае, равно половине этих строк.

Далее в методе FillMatrixFromArr количество строк и столбцов присваиваевается матрице:
int rows = matrix.GetLength(0);
int cols = matrix.GetLength(1);

а также инициализируем переменную для для отслеживания текущего индекса массива array, из которого мы берем данные для заполнения матрицы: 
int index = 0;

С помощью циклов проходимся по строкам и столбцам матрицы:
Внешний цикл идет по строкам матрицы: for (int i = 0; i < rows; i++)
Внутренний цикл идет по столбцам матрицы: for (int j = 0; j < cols; j++)

C помощью условного оператора if проверяем что текущий индекс меньше длинны одномерного массива (index < array.Length). 

Если это условие выполняется, то есть есть еще данные в массиве array для заполнения матрицы, мы выполняем следующие действия:

matrix[i, j] = array[index];: Присваиваем элементу матрицы (i, j) значение из массива array с текущим индексом index.

index++;: Увеличиваем значение index на 1 для перехода к следующему элементу массива array.

Если index превысит array.Length, мы выходим из вложенного цикла for, используя оператор break.

Таким образом, этот метод заполняет двумерную матрицу matrix значениями из одномерного массива array, учитывая количество строк и столбцов в матрице.

## Третий блок

Остально подготовить метод для печати матрицы в консоль.

С помощью функции GetLength получаем количество строк и столбцов.
После этого с помощью внешнего цикла for (int i = 0; i < rows; i++) идем по строкам, а с помощью Console.Write($" {matrix[i, 0]}\t") выводим первый элемент каждой строки без перевода строки. 
Используем Console.Write, чтобы значения выводились в одну строку.
Далее с помощью внутреннего цикла идем по столбцам, начиная со второго:
for (int j = 1; j < cols; j++) и также вывводим каждый следующий элемент разделяя их символом табуляции \t
Console.Write($" {matrix[i, j]}\t").

## Четвертый блок

Теперь программа готова к печати пользовательских данных в виде матрицы с помощью метода Main, в котором мы проинициализировали необходимые для методов элементы: PrintMatrix(matrix);

Введите данные для индекса 0 от 0 до 3 символов: 
1
Введите данные для индекса 1 от 0 до 3 символов: 
2
Введите данные для индекса 2 от 0 до 3 символов: 
3
Введите данные для индекса 3 от 0 до 3 символов: 
4
Полученные данные: 
 1       2
 3       4